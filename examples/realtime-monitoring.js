#!/usr/bin/env node

import { DynamixelController } from '../index.js';

/**
 * Example: Real-time Motor Position and Health Monitoring
 * This example sets the first discovered motor to non-torque mode and streams
 * real-time position and health information while you manually turn the motor.
 */

const REFRESH_RATE = 100; // milliseconds (10 Hz) - slower for better reliability
const CLEAR_SCREEN = '\x1Bc'; // Clear terminal screen
const SENSOR_TIMEOUT = 2000; // 2 second timeout for sensor reads

let monitoringActive = false;
let device = null;
let consecutiveErrors = 0;
let lastSuccessfulRead = null;

function formatHealth(health) {
  const status = [];
  
  // Temperature status
  if (health.temperature !== null) {
    if (health.temperature > 70) {
      status.push(`üî• TEMP: ${health.temperature}¬∞C (HIGH)`);
    } else if (health.temperature > 50) {
      status.push(`üü° TEMP: ${health.temperature}¬∞C (WARM)`);
    } else {
      status.push(`üü¢ TEMP: ${health.temperature}¬∞C`);
    }
  } else {
    status.push(`‚ùì TEMP: Error reading`);
  }
  
  // Voltage status
  if (health.voltage !== null) {
    const voltage = health.voltage * 0.1;
    if (voltage < 11.0) {
      status.push(`üîã VOLT: ${voltage.toFixed(1)}V (LOW)`);
    } else if (voltage > 14.0) {
      status.push(`‚ö° VOLT: ${voltage.toFixed(1)}V (HIGH)`);
    } else {
      status.push(`üü¢ VOLT: ${voltage.toFixed(1)}V`);
    }
  } else {
    status.push(`‚ùì VOLT: Error reading`);
  }
  
  // Hardware error status
  if (health.hardwareError !== null) {
    if (health.hardwareError > 0) {
      status.push(`‚ùå HW ERROR: 0x${health.hardwareError.toString(16).padStart(2, '0')}`);
    } else {
      status.push(`‚úÖ HW STATUS: OK`);
    }
  } else {
    status.push(`‚ùì HW STATUS: Error reading`);
  }
  
  return status;
}

function formatPosition(position, velocity) {
  if (position === null || velocity === null) {
    return {
      degrees: 'Error',
      rpm: 'Error',
      gauge: '‚ñà'.repeat(20) + '‚ñë'.repeat(20),
      rawPosition: position || 'Error',
      rawVelocity: velocity || 'Error'
    };
  }
  
  const degrees = ((position / 4095) * 360).toFixed(1);
  const rpm = (velocity * 0.229).toFixed(1);
  
  // Create a simple ASCII gauge for position (0-360 degrees)
  const gaugeWidth = 40;
  const gaugePosition = Math.round((position / 4095) * gaugeWidth);
  const gauge = '‚ñà'.repeat(gaugePosition) + '‚ñë'.repeat(gaugeWidth - gaugePosition);
  
  return {
    degrees,
    rpm,
    gauge,
    rawPosition: position,
    rawVelocity: velocity
  };
}

async function safeRead(readFunction, fallbackValue = null) {
  try {
    return await readFunction();
  } catch (_error) {
    return fallbackValue;
  }
}

async function monitorDevice() {
  if (!device || !monitoringActive) return;
  
  try {
    // Read sensors sequentially with individual error handling for better reliability
    const position = await safeRead(() => device.getPresentPosition());
    const velocity = await safeRead(() => device.getPresentVelocity());
    const temperature = await safeRead(() => device.getPresentTemperature());
    const voltage = await safeRead(() => device.getPresentVoltage());
    const hardwareError = await safeRead(() => device.readByte(70)); // HARDWARE_ERROR_STATUS
    const moving = await safeRead(() => device.isMoving(), false);
    
    // Clear screen and display header AFTER sensor reads to prevent scrolling
    console.log(CLEAR_SCREEN);
    console.log('üîÑ DYNAMIXEL REAL-TIME MONITOR');
    console.log('‚ïê'.repeat(60));
    console.log(`üìç Motor ID: ${device.id} (${device.modelName || 'Unknown Model'})`);
    console.log(`üîß Torque: DISABLED (Manual Mode)`);
    console.log('');
    
    const health = {
      temperature,
      voltage,
      hardwareError,
      moving
    };
    
    const pos = formatPosition(position, velocity);
    const healthStatus = formatHealth(health);
    
    // Check if we got any successful reads
    const hasValidData = position !== null || velocity !== null || temperature !== null;
    
    if (hasValidData) {
      consecutiveErrors = 0;
      lastSuccessfulRead = Date.now();
    } else {
      consecutiveErrors++;
    }
    
    // Position display
    console.log('üìê POSITION & MOVEMENT:');
    console.log(`   Position: ${pos.degrees}¬∞ (${pos.rawPosition}/4095)`);
    console.log(`   Velocity: ${pos.rpm} RPM (${pos.rawVelocity})`);
    console.log(`   Gauge:    |${pos.gauge}|`);
    console.log(`             0¬∞                    180¬∞                  360¬∞`);
    console.log(`   Moving:   ${health.moving ? 'üü¢ YES' : '‚ö™ NO'}`);
    console.log('');
    
    // Health display
    console.log('üè• HEALTH STATUS:');
    healthStatus.forEach(status => console.log(`   ${status}`));
    console.log('');
    
    // Communication status
    if (consecutiveErrors > 0) {
      console.log('‚ö†Ô∏è  COMMUNICATION STATUS:');
      console.log(`   Consecutive errors: ${consecutiveErrors}`);
      if (lastSuccessfulRead) {
        const timeSince = Math.round((Date.now() - lastSuccessfulRead) / 1000);
        console.log(`   Last successful read: ${timeSince}s ago`);
      }
      console.log('');
    }
    
    console.log('üí° Instructions:');
    console.log('   ‚Ä¢ Manually turn the motor to see position changes');
    console.log('   ‚Ä¢ Press Ctrl+C to stop monitoring');
    console.log('');
    console.log(`üïê Last update: ${new Date().toLocaleTimeString()}`);
    
    // If too many consecutive errors, suggest troubleshooting
    if (consecutiveErrors > 10) {
      console.log('');
      console.log('üö® TROUBLESHOOTING:');
      console.log('   ‚Ä¢ Check power supply to motors');
      console.log('   ‚Ä¢ Verify cable connections');
      console.log('   ‚Ä¢ Try slower refresh rate');
      console.log('   ‚Ä¢ Run: npm run diagnostics');
    }
    
  } catch (error) {
    consecutiveErrors++;
    console.log(CLEAR_SCREEN);
    console.log('‚ùå DYNAMIXEL REAL-TIME MONITOR - ERROR');
    console.log('‚ïê'.repeat(60));
    console.log(`üìç Motor ID: ${device.id} (${device.modelName || 'Unknown Model'})`);
    console.log(`‚ùå Monitor error: ${error.message}`);
    console.log(`   Consecutive errors: ${consecutiveErrors}`);
    console.log('   Continuing to retry...');
    console.log('');
    console.log('üí° Instructions:');
    console.log('   ‚Ä¢ Check device connection');
    console.log('   ‚Ä¢ Press Ctrl+C to stop monitoring');
    console.log('');
    console.log(`üïê Last attempt: ${new Date().toLocaleTimeString()}`);
  }
}

async function startMonitoring() {
  console.log(CLEAR_SCREEN);
  console.log('üöÄ Starting real-time monitoring...\n');
  
  monitoringActive = true;
  
  // Start monitoring loop
  const monitorInterval = setInterval(monitorDevice, REFRESH_RATE);
  
  // Handle graceful shutdown
  process.on('SIGINT', async() => {
    console.log('\n\nüõë Stopping monitor...');
    monitoringActive = false;
    clearInterval(monitorInterval);
    
    try {
      if (device) {
        console.log('üîß Re-enabling torque...');
        await device.setTorqueEnable(true);
        console.log('‚úÖ Torque re-enabled');
      }
    } catch (error) {
      console.error('‚ö†Ô∏è  Warning: Could not re-enable torque:', error.message);
    }
    
    process.exit(0);
  });
}

async function main() {
  console.log('üéØ DYNAMIXEL Real-time Position & Health Monitor');
  console.log('‚ïê'.repeat(60));
  console.log('This example will disable torque on the first discovered motor');
  console.log('and stream real-time position and health data.\n');
  
  // Create controller with longer timeout for better reliability
  const controller = new DynamixelController({
    timeout: SENSOR_TIMEOUT,
    debug: false
  });
  
  // Set up event listeners
  controller.on('connected', () => {
    console.log('‚úÖ Connected to U2D2 device');
  });
  
  controller.on('error', (error) => {
    console.error('‚ùå Controller error:', error.message);
  });
  
  try {
    // Connect to U2D2
    console.log('üîå Connecting to U2D2...');
    await controller.connect();
    
    // Try to find device ID 1 first (most common setup)
    console.log('üîç Looking for device ID 1...');
    try {
      await controller.ping(1, SENSOR_TIMEOUT);
      device = controller.getDevice(1);
      console.log(`‚úÖ Found device ID 1: ${device.modelName || 'Unknown Model'}`);
    } catch (_error) {
      console.log('‚ö†Ô∏è  Device ID 1 not found, trying broader discovery...');
      
      // Fall back to full discovery if ID 1 not found
      console.log('üîç Discovering DYNAMIXEL devices...');
      const devices = await controller.quickDiscovery();
      
      if (devices.length === 0) {
        console.log('‚ùå No DYNAMIXEL devices found!');
        console.log('\nTroubleshooting:');
        console.log('‚Ä¢ Check power supply to motors');
        console.log('‚Ä¢ Verify correct baud rate (57600)');
        console.log('‚Ä¢ Ensure proper wiring');
        console.log('‚Ä¢ Try running: npm run diagnostics');
        process.exit(1);
      }
      
      // Use first discovered device
      const deviceInfo = devices[0];
      device = controller.getDevice(deviceInfo.id);
      
      console.log(`‚úÖ Found ${devices.length} device(s)`);
      console.log(`üéØ Using device ID ${device.id}: ${device.modelName || 'Unknown Model'}`);
    }
    
    // Test device communication
    console.log('üì° Testing device communication...');
    const testPosition = await device.getPresentPosition();
    console.log(`‚úÖ Communication OK - Position: ${testPosition}`);
    
    // Check current torque status
    const currentTorque = await device.getTorqueEnable();
    console.log(`üîß Current torque status: ${currentTorque ? 'ENABLED' : 'DISABLED'}`);
    
    // Disable torque for manual operation
    console.log('üîß Disabling torque for manual operation...');
    await device.setTorqueEnable(false);
    
    // Verify torque is disabled
    const torqueDisabled = !(await device.getTorqueEnable());
    if (!torqueDisabled) {
      throw new Error('Failed to disable torque');
    }
    
    console.log('‚úÖ Torque disabled - motor can now be turned manually');
    console.log('‚è∞ Starting monitoring in 2 seconds...\n');
    
    // Brief pause before starting monitor
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Start real-time monitoring
    await startMonitoring();
    
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  }
}

// Handle uncaught errors
process.on('unhandledRejection', (error) => {
  console.error('‚ùå Unhandled error:', error.message);
  process.exit(1);
});

main().catch(console.error);